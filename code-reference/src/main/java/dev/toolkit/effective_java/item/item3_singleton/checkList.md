## 📌 목차

### 싱글턴을 사용에 따라 구현 방법 예시
- [📌 1. API를 바꾸지 않고도 싱글턴이 아닌 방식으로 변경해야 할 때](#📌-1-api를-바꾸지-않고도-싱글턴이-아닌-방식으로-변경해야-할-때)
- [📌 2. 멀티스레드 환경에서 스레드별로 동일 인스턴스를 반환해야 할 때](#📌-2-멀티스레드-환경에서-스레드별로-동일-인스턴스를-반환해야-할-때)
- [📌 3. 다양한 타입에 대해 싱글턴을 적용해야 할 때](#📌-3-다양한-타입에-대해-싱글턴을-적용해야-할-때)
- [📌 4. 리플렉션 공격을 방어해야 할 때](#📌-4-리플렉션-공격을-방어해야-할-때)
- [📌 5. 싱글턴을 가장 안전하고 간단하게 구현해야 할 때](#📌-5-싱글턴을-가장-안전하고-간단하게-구현해야-할-때)

### 싱글턴 패턴을 사용하지 말아야 할 경우
- [📌 싱글턴 패턴을 사용하지 말아야 할 경우](#📌-싱글턴-패턴을-사용하지-말아야-할-경우)

### 결론
- [📌 결론](#📌-결론)

---

## 📌 1. API를 바꾸지 않고도 싱글턴이 아닌 방식으로 변경해야 할 때
- [ ] **정적 팩터리 메서드를 통한 동일 인스턴스 반환**을 사용하자.  
  → 생성자 대신 `getInstance()` 같은 정적 팩터리 메서드를 제공하면, 싱글턴을 유지하면서도 필요에 따라 다중 인스턴스를 반환하도록 변경 가능.  
  **➡ 예시:** `RemoteControl.getInstance()`

   <br>

**[단점]**

- ❌ **싱글턴임이 API에서 명확하지 않음** (`getInstance()`를 호출해야 싱글턴인지 알 수 있음)
- ❌ **public 필드 방식보다 코드가 다소 복잡해질 수 있음**  
  
---

## 📌 2. 멀티스레드 환경에서 스레드별로 동일 인스턴스를 반환해야 할 때
- [ ] **스레드별로 동일 인스턴스를 반환하도록 하는 방법 (단, 다른 스레드끼리는 다른 인스턴스 반환)**을 사용하자.  
  → `ThreadLocal<T>`을 활용하면 **각 스레드마다 고유한 싱글턴 인스턴스 유지** 가능.  
  **➡ 예시:** `ThreadLocal<ThreadLocalRemoteControl>`

---

## 📌 3. 다양한 타입에 대해 싱글턴을 적용해야 할 때
- [ ] **제네릭을 사용한 싱글턴 팩터리**를 활용하자.  
  → `EnumMap` 또는 `ConcurrentHashMap`을 활용하여 **타입별로 유일한 인스턴스를 관리**.  
  **➡ 예시:** `private static final Map<RemoteType, RemoteControl> instances = new ConcurrentHashMap<>();`

---

## 📌 4. 리플렉션 공격을 방어해야 할 때
- [ ] **리플렉션 공격을 방어하는 싱글턴**을 사용하자.  
  → 생성자에서 예외 처리를 추가하여 리플렉션을 통한 새로운 인스턴스 생성을 차단하자.
  
    → 기존 인스턴스가 존재할 경우, 예외를 던지는 방식으로 보호.  
  **➡ 예시:**
    ```java
     if (INSTANCE != null) { // 리플렉션 방어
            throw new IllegalStateException("Cannot create instance via reflection.");
        }
    ```
  <br>

**[단점]**

- ❌**완벽한 리플렉션 방어는 불가능**

    → **리플렉션을 사용하면 private 생성자도 강제로 변경할 수 있어,**

    **→ 완벽한 방어는 어려움.**

---

## 📌 5. 싱글턴을 가장 안전하고 간단하게 구현해야 할 때
- [ ] **열거 타입(Enum) 사용 싱글턴 코드**를 활용하자.  
  → `enum`을 사용하면 **리플렉션 및 직렬화 문제를 자동으로 해결**하면서도 **가장 간단한 싱글턴 구현 가능**.  
  **➡ 예시:**
  ```java
  enum RemoteControl{
    INSTANCE;

    public void contorl() {
        System.out.println("RemoteControl control");
      }
  }
  ```
  ➡ 사용법: RemoteControl.INSTANCE.control();

   <br>

**[단점]**

- ❌ 다른 클래스를 상속할 수 없음 (enum은 다른 클래스를 상속할 수 없지만 인터페이스 구현은 가능)

---

## 📌 싱글턴 패턴을 사용하지 말아야 할 경우

✔ **싱글턴 패턴이 강력한 기법이지만, 모든 경우에 적절한 것은 아니다.**  
✔ **아래 조건에 해당하면 일반적인 객체 생성 패턴이 더 적절할 수 있다.**

- ❌ **테스트가 어려워지는 경우** → 의존성 주입(DI)과 팩토리 패턴을 고려하자.
- ❌ **멀티 인스턴스가 필요할 가능성이 있는 경우** → 단순히 new를 사용하는 것과 팩토리 패턴을 활용하여 유연성을 확보하자.
- ❌ **상태를 변경할 가능성이 있는 경우** → 싱글턴은 상태를 공유하기 때문에 예상치 못한 문제 발생 가능.
- ❌ **멀티스레드 환경에서 동시 접근이 빈번한 경우** → 동기화 비용이 발생할 수 있으므로 주의.

---

## 📌 결론

✔ **싱글턴 패턴은 한 개의 인스턴스만 필요할 때 강력한 패턴이다.**  
✔ **하지만, 테스트 용이성, 유연성, 유지보수성을 고려하여 적절한 방식으로 적용해야 한다.**   
