## 목차
### 빌더 패턴을 사용해야 하는 경우
- [📌 1. 객체의 속성이 많고 선택적 매개변수가 많을 때](#📌-1-객체의-속성이-많고-선택적-매개변수가-많을-때)
- [📌 2. 객체 생성 과정이 복잡하고 가독성을 높이고 싶을 때](#📌-2-객체-생성-과정이-복잡하고-가독성을-높이고-싶을-때)
- [📌 3. 불변 객체(Immutable Object)를 만들어야 할 때](#📌-3-불변-객체immutable-object를-만들어야-할-때)
- [📌 4. 객체 확장이 필요하고 계층적 구조를 유지해야 할 때](#📌-4-객체-확장이-필요하고-계층적-구조를-유지해야-할-때)
- [📌 5. 메서드 체이닝 방식으로 유연한 설정이 필요할 때](#📌-5-메서드-체이닝-방식으로-유연한-설정이-필요할-때)
- [📌 6. 생성자 오버로딩이 너무 많아지는 경우](#📌-6-생성자-오버로딩이-너무-많아지는-경우)
- [📌 7. 객체의 유효성 검사 및 불변식 검사가 필요한 경우](#📌-7-객체의-유효성-검사-및-불변식-검사가-필요한-경우)
- [📌 8. 동일한 객체를 기반으로 일부 속성만 변경하여 새로운 객체를 생성해야 할 때](#📌-8-동일한-객체를-기반으로-일부-속성만-변경하여-새로운-객체를-생성해야-할-때)
- [📌 9. 객체 생성 비용이 크고, 객체 생성을 최적화해야 하는 경우](#📌-9-객체-생성-비용이-크고-객체-생성을-최적화해야-하는-경우)
- [📌 10. 유지보수성과 확장성이 중요한 경우](#📌-10-유지보수성과-확장성이-중요한-경우)

### 빌더 패턴이 적절하지 않은 경우
- [📌 하지만! 빌더 패턴이 적절하지 않은 경우](#📌-하지만-빌더-패턴이-적절하지-않은-경우)

---

## **📌 1. 객체의 속성이 많고 선택적 매개변수가 많을 때**
- [ ] 객체의 필수 속성과 선택적 속성이 많아 **생성자 오버로딩이 과도해지는 경우**
- [ ] 객체 생성 시 **모든 속성을 한 번에 설정하지 않고, 일부 속성만 설정할 가능성이 높은 경우**

➡ **예시:** `GameCharacter`, `Car`, `Config`

---

## **📌 2. 객체 생성 과정이 복잡하고 가독성을 높이고 싶을 때**
- [ ] **생성자 매개변수가 많아 코드의 가독성이 떨어지는 경우**
- [ ] **매개변수의 의미를 명확하게 하고, 가독성을 높이고 싶은 경우**
- [ ] **객체 생성 시 필수 속성과 선택 속성을 명확하게 구분하고 싶은 경우**

➡ **예시:** `NutritionFacts`, `HttpRequest`, `UserProfile`

---

## **📌 3. 불변 객체(Immutable Object)를 만들어야 할 때**
- [ ] **객체가 한 번 생성된 후 값이 변경되지 않아야 하는 경우**
- [ ] **불변성을 유지하면서도 객체를 쉽게 생성할 수 있도록 하고 싶은 경우**
- [ ] **객체의 필드가 `final`이어야 하고, setter를 사용할 수 없는 경우**

➡ **예시:** `Person`, `ImmutableConfig`, `UserAccount`

---

## **📌 4. 객체 확장이 필요하고 계층적 구조를 유지해야 할 때**
- [ ] **객체가 부모-자식 클래스로 확장될 가능성이 있는 경우**
- [ ] **부모 클래스에서 공통 속성을 정의하고, 자식 클래스에서 추가 속성을 설정해야 하는 경우**
- [ ] **계층적 빌더 패턴(Hierarchical Builder)을 적용해야 하는 경우**

➡ **예시:** `Coffee -> NonMilkCoffee -> Espresso`, `Vehicle -> Car -> ElectricCar`

---

## **📌 5. 메서드 체이닝 방식으로 유연한 설정이 필요할 때**
- [ ] **객체 생성 시 플루언트 API(Fluent API) 방식을 적용하여 체이닝을 가능하게 하고 싶은 경우**
- [ ] **객체의 속성을 한 줄로 간결하게 설정할 수 있도록 하고 싶은 경우**

➡ **예시:** `QueryBuilder`, `HttpRequestBuilder`, `LoggerConfig`

---

## **📌 6. 생성자 오버로딩이 너무 많아지는 경우**
- [ ] **다양한 조합의 생성자를 제공해야 하며, 생성자 개수가 기하급수적으로 증가하는 경우**
- [ ] **매개변수 개수가 많아질수록 생성자 관리가 어려워지는 경우**

➡ **예시:** `GameCharacter`, `Car`, `Order`

---

## **📌 7. 객체의 유효성 검사 및 불변식 검사가 필요한 경우**
- [ ] **객체 생성 시 값의 유효성을 검사해야 하는 경우**
- [ ] **객체가 생성될 때 여러 매개변수 간 관계(불변식)를 검사해야 하는 경우**
- [ ] **객체가 잘못된 상태로 생성되는 것을 방지해야 하는 경우**

➡ **예시:** `User`, `Product`, `AccountSettings`

---

## **📌 8. 동일한 객체를 기반으로 일부 속성만 변경하여 새로운 객체를 생성해야 할 때**
- [ ] **기존 객체의 일부 속성만 변경하고 싶지만, 불변성을 유지해야 하는 경우**
- [ ] **객체 변경을 위해 새로운 객체를 생성해야 하는 경우 (`toBuilder()` 패턴 활용)**

➡ **예시:** `ImmutablePerson.toBuilder()`, `Order.toBuilder()`

---

## **📌 9. 객체 생성 비용이 크고, 객체 생성을 최적화해야 하는 경우**
- [ ] **객체를 생성할 때 복잡한 초기화 과정이 필요한 경우**
- [ ] **객체 생성 비용이 높아, 필요한 속성만 설정하여 객체를 효율적으로 생성해야 하는 경우**

➡ **예시:** `DatabaseConnection`, `HttpClient`, `ReportGenerator`

---

## **📌 10. 유지보수성과 확장성이 중요한 경우**
- [ ] **새로운 속성이 추가될 가능성이 높고, 객체 생성 코드를 쉽게 확장해야 하는 경우**
- [ ] **객체의 구조를 변경하더라도 기존 코드의 변경을 최소화해야 하는 경우**

➡ **예시:** `ConfigSettings`, `LoggerConfig`, `FeatureFlags`

---

## **📌 하지만! 빌더 패턴이 적절하지 않은 경우**
✔ 빌더 패턴이 강력한 기법이지만, 모든 경우에 적절한 것은 아니다.  
✔ 아래 조건에 해당하면 **일반 생성자 또는 다른 패턴이 더 적절할 수 있다.**

- ❌ **객체가 단순하고, 필드 개수가 적은 경우 (3~4개 이하)**
- ❌ **객체 속성이 자주 변경되며, setter를 자주 사용해야 하는 경우**
- ❌ **객체 생성 후에도 특정 필드만 자주 변경해야 하는 경우 (`update()` 패턴이 더 적절함)**
- ❌ **객체를 재사용해야 하며, 매번 새로운 인스턴스를 만들 필요가 없는 경우 (싱글턴 또는 정적 팩터리 메서드가 적절함)**
- ❌ **객체의 생명주기가 짧아, 생성 비용을 고려할 필요가 없는 경우**

➡ **대안:**  
✔ **단순한 객체** → 일반 생성자 사용  
✔ **값이 자주 변경되는 객체** → Setter 또는 `update()` 패턴 적용  
✔ **객체 재사용이 필요한 경우** → 싱글턴 패턴 또는 정적 팩터리 메서드 적용

---

## **📌 결론**
✔ **빌더 패턴은 객체의 속성이 많고 선택적 속성이 많을 때 유용하다.**  
✔ **객체 생성이 복잡하고, 가독성을 높여야 하며, 불변성을 유지해야 하는 경우에 적합하다.**  
✔ **하지만, 객체가 단순하거나 값이 자주 변경되는 경우에는 적절하지 않을 수 있다.**
