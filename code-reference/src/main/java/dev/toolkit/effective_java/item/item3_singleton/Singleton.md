## 📌 싱글턴 패턴 개요

### ✅ **싱글턴(Singleton)이란?**

- 클래스의 인스턴스를 **오직 하나만 생성**하도록 보장하는 패턴.
- 주로 **무상태 객체**, **설계상 유일해야 하는 시스템 컴포넌트**에서 사용됨.
- 예: 데이터베이스 연결 객체, 로깅 시스템, 설정(Configuration) 객체 등.

---

## 📌 **싱글턴 패턴의 문제점**

### 🚨 **1. 테스트(Mock)하기 어려움**

- **싱글턴 객체는 전역적으로 하나만 존재**하기 때문에, **Mock 객체로 대체하기 어려움**.
- `private` 생성자로 인해 **상속 및 객체 생성이 제한**되어, 새로운 인스턴스를 만들기 어려움.

   <br>

✔ **해결 방법**

1. **인터페이스를 활용**하여 싱글턴을 구현하면, Mock 객체로 대체 가능.
2. `spy()`를 사용하여 기존 싱글턴 인스턴스를 감싸 특정 메서드만 Mocking.

---

### 🚨 **2. 리플렉션(Reflection) 공격 가능**

- `AccessibleObject.setAccessible(true)`를 사용하면 `private` 생성자를 강제로 호출할 수 있음.
- 이를 통해 **새로운 인스턴스를 생성**하여 싱글턴이 깨질 수 있음.

   <br>

✔ **해결 방법**

1. 생성자에서 **이미 인스턴스가 존재하는지 검사**하고, 있으면 예외를 던지도록 구현.
2. 하지만 **리플렉션을 통해 `private` 필드도 변경할 수 있어 완벽한 방어는 불가능**.

---

### 🚨 **3. 직렬화(Serialization) 시 싱글턴 깨짐**

- 싱글턴 객체를 직렬화하면, **역직렬화할 때 새로운 인스턴스가 생성**됨.
- 즉, `INSTANCE`가 아닌 새로운 객체가 반환되어 싱글턴이 깨질 수 있음.

   <br>

✔ **해결 방법**

1. `readResolve()` 메서드를 추가하여 **기존 인스턴스를 반환**하도록 수정.

---

### 🚨 **4. 멀티스레드 환경에서 동기화 문제**

- 여러 스레드가 동시에 인스턴스를 생성하려 하면 **동기화 문제가 발생할 수 있음**.

   <br>

✔ **해결 방법**

1. `synchronized`를 사용하여 동기화.
2. **정적 초기화 방식** 또는 **이른 초기화(Eager Initialization)** 를 사용하여 해결 가능.

---

## 📌 **싱글턴을 구현하는 3가지 방법**

### ✅ **1. `public static final` 필드 방식**

```java
public class Elvis {
    public static final Elvis INSTANCE = new Elvis();
    private Elvis() {} // private 생성자로 외부 인스턴스 생성을 방지
}
```

✔ **장점**

- API에서 **싱글턴임이 명확**함.
- `static final` 필드이므로 **한 번 초기화되면 변경 불가능**.
- 코드가 **간결**하고 이해하기 쉬움.

   <br>

❌ **단점**

- 싱글턴을 **해제할 수 없음** (`INSTANCE`가 고정됨).
- **리플렉션 공격**으로 새로운 인스턴스를 만들 수 있음.

---

### ✅ **2. 정적 팩터리 메서드 방식**

```java
public class Elvis {
    private static final Elvis INSTANCE = new Elvis();
    private Elvis() {}

    public static Elvis getInstance() {
        return INSTANCE;
    }
}
```

✔ **장점**

- **API를 변경하지 않고 싱글턴을 유연하게 변경 가능** (예: 스레드별 다른 인스턴스 제공).
- **제네릭 싱글턴 팩터리**로 확장 가능.
- `Supplier<Elvis>` 같은 **함수형 인터페이스와 결합 가능**.

   <br>

❌ **단점**

- `getInstance()`를 호출해야 싱글턴인지 알 수 있음.
- 코드가 `public static final` 방식보다 다소 복잡함.

---

### ✅ **3. `enum` 방식 - 가장 안전한 방식**

```java
public enum Elvis {
    INSTANCE;

    public void sing() {
        System.out.println("Elvis is singing!");
    }
}
```

✔ **장점**

- **가장 안전한 싱글턴 구현 방법** (리플렉션 공격 방어 + 직렬화 지원).
- 코드가 가장 **간결**함.
- `Serializable`을 구현하지 않아도 자동으로 직렬화 가능.

   <br>

❌ **단점**

- **다른 클래스를 상속할 수 없음** (`enum`은 상속 불가, 인터페이스 구현만 가능).

💡 **가능하면 enum 방식이 가장 안전함!**

---

## 📌 **싱글턴을 도입해야 하는 경우 (체크리스트)**

✔ 아래 조건 중 하나라도 충족되면 싱글턴 패턴을 고려해야 한다.

- [ ]  **애플리케이션 내에서 유일한 인스턴스가 필요할 때**

   → 데이터베이스 연결, 로깅 시스템, 설정(Configuration) 관리 등.

  

- [ ]  **객체가 상태를 유지하지 않고 공유 가능할 때**
  
   → 무상태 객체(Stateless Object) 예: `Math`, `Utility` 클래스.


- [ ]  **객체 생성 비용이 높아 인스턴스를 공유하는 것이 유리할 때**
  
   → 객체를 매번 생성하면 부담이 클 경우, 싱글턴으로 관리.


- [ ]  **멀티스레드 환경에서 동일한 인스턴스를 사용해야 할 때**
  
   → 싱글턴을 통해 **동기화 문제를 방지**하고, 성능을 최적화할 수 있음.

---

## 📌 **싱글턴을 사용하지 말아야 할 경우**

✔ 싱글턴 패턴이 강력한 기법이지만, 모든 경우에 적절한 것은 아니다.

- ❌ **객체가 상태를 가지며, 다중 인스턴스가 필요한 경우**
  
   → 여러 개의 독립적인 인스턴스가 필요하다면 **싱글턴을 사용하면 안 됨**.
  
   <br>

- ❌ **테스트가 어려워지는 경우**

   → **의존성 주입(DI) 및 팩토리 패턴을 고려하자**.

   <br>

- ❌ **멀티 인스턴스가 필요할 가능성이 있는 경우**

   → 팩토리 패턴을 활용하여 유연성을 확보하는 것이 좋음.

   <br>

- ❌ **상태를 변경할 가능성이 있는 경우**

   → 싱글턴은 **상태를 공유**하기 때문에 예상치 못한 문제 발생 가능.

   <br>

- ❌ **멀티스레드 환경에서 동시 접근이 빈번한 경우**

   → 동기화 비용이 발생할 수 있으므로 주의.

---

## 📌 **결론: 가장 좋은 싱글턴 구현 방식**

| 방식 | 장점 | 단점 |
| --- | --- | --- |
| **`public static final` 필드** | API에서 싱글턴이 명확, 간결 | API 변경 없이 싱글턴 해제 불가 |
| **정적 팩터리 메서드** | 유연성 높음 (싱글턴 해제 가능) | 싱글턴임이 API에서 명확하지 않음 |
| **Enum 방식 (🔥 가장 안전)** | 직렬화 지원, 리플렉션 공격 방어 | 다른 클래스 상속 불가 |

---

### **결론**

✔ **가능하면 `enum` 방식이 가장 안전함!**

✔ **싱글턴이 특정 클래스를 상속해야 한다면 `public static final` 또는 `정적 팩터리` 방식 사용**.

✔ **테스트가 필요하면 인터페이스를 사용하여 유연성을 확보해야 함.**

✔ **멀티스레드 환경에서는 동기화를 고려한 싱글턴 구현이 필요함.** 